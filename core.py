import spotipy
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv
import os

load_dotenv()

class myExplorify:
  def __init__(self):
    self.client_id = os.environ.get('SPOTIPY_CLIENT_ID') 
    self.client_secret = os.environ.get('SPOTIPY_CLIENT_SECRET') 
    self.redirect_uri = os.environ.get('SPOTIPY_CLIENT_REDIRECT_URI')
    sp_oauth = SpotifyOAuth(self.client_id, self.client_secret, self.redirect_uri, scope="user-library-read playlist-modify-private") 
    
    # Get authorization URL
    auth_url = sp_oauth.get_authorize_url()

    print(f'Please visit this URL to authorize the application: {auth_url}')

    # Prompt user to enter the URL after authorization
    redirected_url = input('Paste the redirected URL here: ')

    # Parse the response to get access token
    code = sp_oauth.parse_response_code(redirected_url)
    token_info = sp_oauth.get_access_token(code)
    if token_info:
      access_token = token_info['access_token']
      print('Successfully obtained access token!')
      print(f'Your access token is: {access_token}')
      self.sp = spotipy.Spotify(auth=access_token)
    self.namelist = []
    self.linklist = []
    self.imglist = []
    self.artist_dict = {"artist_name": self.namelist, "artist_image": self.imglist, "artist_link": self.linklist}

  def divide_chunks(self, l): #divides large lists into smaller lists for easier API requesting
    for i in range(0, len(l), 50):  
        yield l[i:i + 50] 

  def filter(self, small_list): # checks what songs in a small list are not in users saved/liked track collection
    verified = self.sp.current_user_saved_tracks_contains(small_list)
    verified_list = [] #list of trues and falses
    for i in range(len(verified)):
      if verified[i] == False: #not in collection
        verified_list.append(small_list[i])
    return verified_list    
      
  def check_collection(self, big_list): # checks what songs in a big list are not in users saved/liked track collection
    list_of_chunks = list(self.divide_chunks(big_list)) #list of lists
    return_list = []
    for l in list_of_chunks:
      return_list.extend(self.filter(l))
    return return_list  

  def display_artists(self, name): # displays artists from user search 
    biggest = self.sp.search(q='artist:' + name, limit=9, offset=0, type='artist') #dict
    smaller = biggest['artists']['items'] #list
       
    for each_result in smaller:
      self.linklist.append(each_result['external_urls']['spotify'])
      if len(each_result['images']) > 0:
        self.imglist.append(each_result['images'][0]['url']) #what if no images?
      else:
        self.imglist.append("https://i.imgur.com/HMUuxsO.png")
      self.namelist.append(each_result['name'])
    self.artist_dict.update({"artist_name": self.namelist, "artist_image": self.imglist, "artist_link": self.linklist})  
      
      
  def add__tracks_to_playlist(self, artist_url, artist_name): #adds unheard tracks to users playlist 
    results = self.sp.artist_albums(artist_url, album_type='album') 
    albums = results['items']
    while results['next']:
      results = self.sp.next(results)
      albums.extend(results['items'])

    tracklistforplaylist = []
    tracklistforplaylistnames = []

    for album in albums:
      track_list = self.sp.album_tracks(album['uri'], limit=50, offset=0, market=None)
      for i in range(len(track_list['items'])):
        if track_list['items'][i]['name'] not in tracklistforplaylistnames and track_list['items'][i]['id'] not in tracklistforplaylist:
          tracklistforplaylist.append(track_list['items'][i]['id']) #for each album, add song ids 
          tracklistforplaylistnames.append(track_list['items'][i]['name'])
          i += 1

    results = self.sp.artist_albums(artist_url, album_type='single') #add like eps and stuff
    albums = results['items']
    while results['next']:
        results = self.sp.next(results)
        albums.extend(results['items'])

    for album in albums:
      track_list = self.sp.album_tracks(album['uri'], limit=50, offset=0, market=None)
      for i in range(len(track_list['items'])):
        if track_list['items'][i]['name'] not in tracklistforplaylistnames and track_list['items'][i]['id'] not in tracklistforplaylist:  
          tracklistforplaylist.append(track_list['items'][i]['id'])
          tracklistforplaylistnames.append(track_list['items'][i]['name'])
          i += 1      
  
    tracklistforplaylist = self.check_collection(tracklistforplaylist) #had all the song ids, big list, split into 50 and check each batch of 50
        
    playlist_name = "All: " + str(artist_name) #replace by getting artist name from link
    playlist =  self.sp.user_playlist_create(self.sp.current_user()['id'], playlist_name, public=False, collaborative=False, description='Generated by Explorify') #playlist created yipee
    playlist_id = playlist["id"]
    tracklist_chunks = [tracklistforplaylist[x:x+100] for x in range(0, len(tracklistforplaylist), 100)]
    for chunk in tracklist_chunks:
      self.sp.user_playlist_add_tracks(self.sp.current_user()['id'], playlist_id, chunk, position=None)   #playlist created    
      
  def add_popular_tracks(self, artist_url, artist_name): #adds popular tracks to users playlist
    results = self.sp.artist_albums(artist_url, album_type='album') 
    albums = results['items']
    while results['next']:
      results = self.sp.next(results)
      albums.extend(results['items'])

    tracklistforplaylist = []
    tracklistforplaylistnames = []

    for album in albums:
      track_list = self.sp.album_tracks(album['uri'], limit=50, offset=0, market=None)
      for i in range(len(track_list['items'])):
        if track_list['items'][i]['name'] not in tracklistforplaylistnames and track_list['items'][i]['id'] not in tracklistforplaylist:
          tracklistforplaylist.append(track_list['items'][i]['id']) #for each album, add song ids 
          tracklistforplaylistnames.append(track_list['items'][i]['name'])
          i += 1

    results = self.sp.artist_albums(artist_url, album_type='single') #add like eps and stuff
    albums = results['items']
    while results['next']:
        results = self.sp.next(results)
        albums.extend(results['items'])

    for album in albums:
      track_list = self.sp.album_tracks(album['uri'], limit=50, offset=0, market=None)
      for i in range(len(track_list['items'])):
        if track_list['items'][i]['name'] not in tracklistforplaylistnames and track_list['items'][i]['id'] not in tracklistforplaylist:  
          tracklistforplaylist.append(track_list['items'][i]['id'])
          tracklistforplaylistnames.append(track_list['items'][i]['name'])
          i += 1      
  
    tracklistforplaylist = self.check_collection(tracklistforplaylist) #had all the song ids, big list, split into 50 and check each batch of 50
    tracklistforplaylist#contains song ids, check each and sort based on populairty     
    playlist_name = "This is: " + str(artist_name) #replace by getting artist name from link
    playlist =  self.sp.user_playlist_create(self.sp.current_user()['id'], playlist_name, public=False, collaborative=False, description='Generated by Explorify') #playlist created yipee
    playlist_id = playlist["id"]
    tracklistforplaylist = self.sort_by_popularity(tracklistforplaylist)
    tracklist_chunks = [tracklistforplaylist[x:x+100] for x in range(0, len(tracklistforplaylist), 100)]
    for chunk in tracklist_chunks:
      self.sp.user_playlist_add_tracks(self.sp.current_user()['id'], playlist_id, chunk, position=None)   #playlist created 
      
  def sort_by_popularity(self, list): #sorts a list of songs by their popularity in descending order
    track_tuples = []
    sorted_list_of_ids = []
    for item in list:
      track = self.sp.track(item)#make sure it actually gets the track tho from the url
      popularity = track["popularity"]
      current_tuple = (item, popularity)
      track_tuples.append(current_tuple) 
    sorted_tuples = sorted(track_tuples, key=lambda track: track[1], reverse=True) 
    for item in sorted_tuples:
      sorted_list_of_ids.append(item[0])
    
    sorted_list_of_ids = sorted_list_of_ids[:30]  
      
    return sorted_list_of_ids 